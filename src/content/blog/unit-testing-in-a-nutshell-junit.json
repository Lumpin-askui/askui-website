{
  "id": "unit_testing_in_a_nutshell_junit",
  "slug": "unit-testing-in-a-nutshell-junit",
  "title": "Unit Testing in a Nutshell – JUnit",
  "excerpt": "This post is part of our unit series, covering definitions and best practices. We cover JUnit, which is the most common unit testing framework in Java",
  "content": "<p id=\">JUnit is the most common unit testing framework in Java. Not only is it used for unit testing, it is also highly relevant for integration tests. But we’ll get to that.<br>Let’s start with a simple JUnit test. As you may know from the <a href=\"https://www.askui.com/blog-posts/unit-testing-in-a-nutshell/\" id=\">first part of this unit testing series</a>, a unit test method should be structured by the <strong id=\">Arrange</strong>,<strong id=\"> Act</strong>,<strong id=\"> Assert-Pattern </strong>(AAA). Here’s an example:</p><pre></pre><p id=\">In line 1 is the test suite in form of a Java class. The <em id=\">@Test</em>-Annotation in line 2 allows the JUnit-Runtime to find and execute the test case. The naming convention <em id=\">Should&lt;ExpectedBehavior&gt;When&lt;StateUnderTest&gt;</em> is used as a method name. Then we arrange the test method after the AAA-pattern. Experts usually don’t necessarily stick to this pattern, instead I recommend one liners to reduce the amount of code.</p><h2 id=\">JUnit Lifecycle</h2>\n\n<p id=\">Let’s have a closer look at the functionality of JUnit, starting with its <strong id=\">lifecycle</strong>. What would you guess, how many instances of a test suite with two methods with a <em id=\">@Test</em>-Annotation are started? One or two? The correct answer is two. The JUnit-Engine starts by default for each <em id=\">@Test</em>-annotation method and its own instance. This behavior can be changed to one instance per class with the @TestInstance-Annotation.<br>Why is this important? You can clean up your test code and replace the <em id=\">@BeforeAll</em> method and initialize your ClassUnderTest directly in line 2, because you know now that JUnit starts a new instance for each test method so the ClassUnderTest has not been reset before the test run. </p><pre></pre><h2 id=\">Assumptions, Conditions and Disabling</h2>\n\n<p id=\"><strong id=\">Assumptions</strong> allow you to abort a test by a condition, instead of marking them as failed. &nbsp;For example, when you have a case where a test should only be executed in the CI pipeline with some special credentials, then the following code snippet is the correct choice:</p><pre></pre><p id=\">Instead of aborting a test, it can also be <strong id=\">disabled</strong> by the <em id=\">@Disabled</em> annotation.This is pretty intuitive, but you can also disable a test using a <strong id=\">condition</strong>. Imagine you have a code which is only working for a minimum JRE version, then you can disable it with the following code snippet:</p><pre></pre><p id=\">JUnit also provides the possibility to enable or disable the test based on an OS (<em id=\">@EnableOnOS</em>, <em id=\">@DisabledOnOs</em>), on SystemProperty (<em id=\">@EnabledIfSystemProperty</em>, &nbsp;<em id=\">@DisabledIfSystemProperty</em>), on Environment Variables (<em id=\">@EnabledIfEnvironmentVariable</em>, <em id=\">@DisabledIfEnvironmentVariable</em>) or you can implement a custom condition (<em id=\">@EnabledIf</em>, &nbsp;<em id=\">@DisabledIf</em>)</p><h2 id=\">Test Order</h2>\n\n<p id=\">In some cases the <strong id=\">order</strong> of the executed tests are important. This is especially necessary for integration tests or functional tests. Therefore the <em id=\">@TestMethodOrder</em>-Annotation allows you to choose one of the four ordering methods: <em id=\">@DisplayName</em>, <em id=\">@OrderAnnotation</em>, <em id=\">@Random</em> or <em id=\">@MethodName</em>. Be careful though, this annotation should only be used in conjunction with the class lifecycle (<em id=\">@TestInstance</em>(Lifecycle.PER_CLASS)).Here is a small example:</p><pre></pre><h2 id=\">Repeating Tests, Parameterizing and File System Access</h2>\n\n<p id=\"><strong id=\">Repeating</strong> a test multiple times is unusual, but <em id=\">@RepeatTest</em>-Annotation allows you to do just this. Can you think of a practical case where this is necessary?</p><p id=\">The <em id=\">@ParameterizedTest</em>-Annotation on the other hand is frequently used to check all boundary values of a method. For example, if you want to check if your constructor only accept values from 0 – 10, you can type:</p><pre></pre><p id=\">In these two tests, you have tested all two valid and invalid boundary values for the constructor.<em id=\">@EnumSource</em>, <em id=\">@CsvFileSource</em> or <em id=\">@MethodSource</em> are popular available argument sources. For more information have a look at <a href=\"https://www.baeldung.com/parameterized-tests-junit-5\" id=\">this tutorial by Baeldung</a>.</p><p id=\">In my previous blog post I gave the advice to not access the file system during a test. There are certain cases though where this is inevitable. Especially if you want to test interactions with the <strong id=\">files system</strong> you have to do so. <em id=\">@TempDir</em>-Annotatoin injects a path to a temporary directory into a test method. It takes care of creation and deletion of the temporary directory, so you can focus on implementing the test.</p><pre></pre><h2 id=\">Addition</h2>\n\n<p id=\">An exciting feature is the <strong id=\">dynamic test</strong> generation. It can generate tests during runtime. Maybe you are wondering why this is considered exciting. Sometimes you want to test high level requirements, like all REST endpoints should accept XML and JSON data formats. Normally you would copy the test code from each controller test to another but in some cases this is forgotten or overlooked. In these cases, dynamic tests are a great solution to &nbsp;generate the test code for each endpoint. But this offers content for an entire blog post.</p><p id=\">I hope you enjoyed this article and learned some practical insights for your future tests.</p>",
  "category": "Tutorial",
  "readTime": "4 min read",
  "date": "2024-11-11",
  "publishedAt": "Mon Nov 11 2024 11:02:06 GMT+0000 (Coordinated Universal Time)",
  "author": "dominik-klotz",
  "image": "https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/671a0b3a1fb89bdb928e7f92_unittesting2.webp",
  "featured": false,
  "contentPath": "unit-testing-in-a-nutshell-junit.md"
}