{
  "id": "unit_testing_in_a_nutshell",
  "slug": "unit-testing-in-a-nutshell",
  "title": "Unit Testing in a Nutshell",
  "excerpt": "Everything you need to know about Unit Tests: Definitions, FIRST-Principle, Test Coverage, Code Examples,Naming Conventions,Test Doubles and Patterns.",
  "content": "<p id=\">In this blog post we are going to cover everything you need to know about Unit Tests. This is the first of two blog posts covering Unit Testing. By the end of this post you will have an overview of all the important characteristics, techniques and patterns.</p><p id=\">Let’s start with a quote by Martin Fowler:</p><blockquote id=\">“Every fool can write code that a computer can understand. Good programmers write code that humans understand.”</blockquote><p id=\">Analogous, good Unit Tests are comprehensible to other people, not just machines. Making code and in this case Unit Tests comprehensible to everyone is what we want to call the <em id=\">Art of Unit Testing</em>.</p><h2 id=\"><strong id=\">Why do you need to test?</strong></h2><ol id=\"><li id=\">Write working code</li><li id=\">Keep code working</li><li id=\">Develop faster</li><li id=\">Find bugs before production</li><li id=\">Force us to write testable code</li><li id=\">Humans do mistakes</li></ol>\n\n<p id=\">There are six reasons, the most obvious answer (1) is that you want your code to work properly. But you need to make sure that it (2) keeps working, even when you change the code. Even the tiniest changes can lead to a series of unintended errors. You don’t want your users to find bugs, you want to (3) find bugs before production. The release cycles of updates heavily increased over the last years which means that the (4) development-process needs to be done more quickly. A well written test is the foundation to this. (5) Writing testable code from the beginning is an investment that pays off in the long run, the amount of work just piles up over time. Last but not least, (6) humans make mistakes. Making mistakes is not a problem, not finding them is a problem.</p><h2 id=\"><strong id=\">How Are Unit Tests defined?</strong></h2>\n\n<p id=\">There are various different definitions of Unit Tests, so let’s stick to Martin Fowler one more time, who identified <a href=\"https://martinfowler.com/bliki/UnitTest.html\" id=\">three core characteristics of Unit Tests</a> that every definition shares: Firstly there is a notion that unit tests are low-level, focusing on a small part of the software system. Secondly unit tests are usually written by the programmers themselves using their language dependent unit testing framework, like JUnit, MSTest or NUnit. Thirdly unit tests are expected to be significantly faster than other kinds of tests.</p><p id=\">Elliotte Rusty Harold stripped the definition of Unit Tests down to: “verifying that a known fixed input produces a known fixed output”.<br>But first step back. What is a unit in general? A unit is normally a method, constructor or deconstructor.</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" style=\"max-width:884px\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"884px\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1cc84553c9eae9952d3_63218adf9a57ac0d19c52353_call-dependencies-in-units.png\" loading=\"lazy\" id=\" width=\"auto\" height=\"auto\" alt=\"></div><figcaption id=\">Call dependencies between units</figcaption></figure><p id=\">Units that are to be tested often rely on other units to fulfill their behavior. When testing a unit, all dependencies should be replaced by mocks. A mock object is a simulated object which simulates the behavior of the dependencies. You only want to test the functionality of this unit and not the functionality of the other ones. </p><p id=\">The test calls the unit and it will call our mocks. At the end, we verify that the mocks are called with the expected parameters. (See image below)</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" style=\"max-width:937px\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"937px\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1cc84553c9eae9952d6_63218b2addfb0d3de8964705_mock-expected-behaviour-verify.png\" loading=\"lazy\" id=\" width=\"auto\" height=\"auto\" alt=\"></div><figcaption id=\"><em id=\">Mock call dependencies. Then verify calls with expected parameters</em></figcaption></figure><h2 id=\">What Is the FIRST-Principle?</h2>\n\n<p id=\">When it comes to the properties of Unit Testing, <a href=\"http://agileinaflash.blogspot.com/2009/02/first.html\" target=\"_blank\" id=\">Brett Schuchert and Tim Ottinger</a> came up with the <strong id=\">FIRST Principle</strong>: <strong id=\">F</strong>ast, <strong id=\">I</strong>ndependent, <strong id=\">R</strong>epeatable, <strong id=\">S</strong>elf-Checking and <strong id=\">T</strong>imely. Writing your Unit Tests with these properties in mind keeps your code clean.</p><p id=\">Your Unit Test has to be <strong id=\">fast</strong>. Most projects cover hundreds of thousands of tests. A test that takes 0.5 or even 0.25 seconds to complete is unacceptably slow. Time is money, make your tests as fast as possible.</p><p id=\">An <strong id=\">independent</strong> test does not rely on any subset in a specific order. You can run every test without constraint. Passing or failing should not depend on the order in which the test was run. Tim Ottinger also refers to the “I” in FIRST as isolated.</p><p id=\"><strong id=\">Repeatable</strong> means that tests must be able to be run repeatedly without intervention. They must not depend upon a specific initial state and they must not leave any problems behind that would prevent them from being re-run. They have to be run repeatedly in any order at any time.</p><p id=\"><strong id=\">Self-checking</strong> or <strong id=\">self-validating</strong> means that a test can automatically detect if it was passed or failed. There is no additional instance needed to confirm or validate the result.</p><p id=\"><strong id=\">Tests</strong> are written at the right time, immediately before the code that makes the tests pass. Writing the test first makes a difference, don’t write them after you write your code.</p><h2 id=\">Do You Know Your Test Coverage?</h2>\n\n<p id=\">Let’s talk about <strong id=\">Code Coverage</strong> or <strong id=\">Test Coverage</strong> as some like to call it. Coverage shows you which lines and branches of the code were (or were not) covered by the tests. It is also a metric which helps you to find out the percentage of your covered (executed) code by the tests. E.g.: It tells you that your codebase consists of 10 lines, 8 lines were being covered by your tests, so your coverage is 80%. While this gives you no information about the quality of your software or how good your tests really are. The coverage of the complete code base should be higher than 80%.</p><p id=\">Code coverage is useful for core refactoring, too. Execute it before you start, check which code branches are covered, add the missing tests and start refactoring your tests.</p><h2 id=\">What Is the Best Way to Write Unit Tests?</h2>\n\n<p id=\">Last but not least: how should your Unit Tests be written? What are the Do’s and Don’ts, what do the naming conventions and building patterns look like and how is the code structured? Let’s start by prefacing some general tips before you actually start writing your code.<br>In the FIRST-Principle we already came across the term<em id=\"> clean code</em>. The term deviates from the Clean Code book by Robert Cecil Martin. In a nutshell, clean code is any code that can be understood intuitively – by others, not just by yourself. Next up is Dependency Injection (DI) – it’s not necessary but highly recommended to isolate your dependencies in the code. This allows you to easily inject your mocks to your class and only test the unit.</p><p id=\">Some general Do’s you should consider:</p>\n\n<ul id=\"><li id=\">One assert per test method</li><li id=\">Share setup and fixture</li><li id=\">Multiple test classes per class</li></ul>\n\n<p id=\">Avoid these Don’ts:</p>\n\n<ul id=\"><li id=\">Generate random input</li><li id=\">Access network or file system</li><li id=\">Names constants from model code. </li><li id=\">Conditions</li><li id=\">Using description annotations</li></ul>\n\n<p id=\">First code example: to avoid god testing classes you can split your test class in multiple test classes. Then test only a single method in your test class, as shown in the next code example.</p><pre></pre><p id=\">Second code example: Never ever (!) use conditions or loops in test methods. Each test method should only test one test case. Split them in multiple test methods.</p><pre></pre><p id=\">Third code example: Warning! When you call static methods from external dependencies, the behavior is not only changed in this test method it is also changed in all other test methods. If you run them at the same time it can result in flaky tests.</p><pre></pre><h2 id=\">Have You Already Thought About Naming Your Test Methods?</h2>\n\n<p id=\">Talking about intuitive, clean and easy to understand code (for everybody), let’s have a look at a few common naming conventions for test methods. There are some general recommendations regarding <a href=\"https://medium.com/@stefanovskyi/unit-test-naming-conventions-dd9208eadbea\" target=\"_blank\" id=\">test naming</a> (Stefanovskiy):</p>\n\n<ul id=\"><li id=\">Test name should express a specific requirement</li><li id=\">Test name could include the expected input or state and the expected result for that input or state</li><li id=\">Test name should be presented as a statement or fact of life that expresses workflows and outputs</li><li id=\">Test name could include the name of the tested method or class</li></ul>\n\n<p id=\">An example might be:</p>\n\n<ol id=\"><li id=\">&lt;MethodName&gt;_&lt;StateUnderTest&gt;_&lt;ExpectedBehavior&gt;<br>isEighteen_AgeGreaterThan18_True<br><strong id=\">Cons:</strong><br>Renaming of method name is necessary, when renaming the origin method<br>‍</li><li id=\">&lt;MethodName&gt;_&lt;ExpectedBehavior&gt;_&lt;StateUnderTests&gt;<br>isEighteen_True_AgeGreaterThan18<br><strong id=\">Cons:</strong><br>Renaming of method name is necessary, when renaming the origin method<br>‍</li><li id=\">test[Feature being tested]<br>testIsEighteenIfAgeGreaterThan18<br><strong id=\">Cons:</strong><br>test-prefix is duplicated information in combination of an @Test-annotation <br>‍</li><li id=\">Feature to be tested<br>isEighteenIfAgeGreaterThan18<br><strong id=\">Cons:</strong><br>Expected result is not defined<br>‍</li><li id=\">Should_&lt;ExpectedBehavior&gt;_When_&lt;StateUnderTest&gt;<br>Should_True_When_AgeGreaterThan18<br><strong id=\">Cons:</strong><br>Long name through should and when</li><li id=\">When_&lt;StadeUnderTest&gt;_Expect_&lt;ExpectedBehavior&gt;<br>When_AgeGreaterThan18_True<br><strong id=\">Cons:</strong><br>Long name through should and expect<br>‍</li><li id=\">Given_&lt;Prediction&gt;_When_&lt;StateUnderTest&gt;_Then_&lt;ExpectedBehavior&gt;<br>Give_UserIsUnder18_When_AgeGreaterThan18_Then_False<br><strong id=\">Cons:</strong><br>Given, When and then are duplicated</li></ol>\n\n<p id=\">It does not matter which naming convention you choose, but your team should use one consistently. Personally I prefer a combination of 1 and 5 &lt;MethodName&gt;_Should_&lt;ExpectedBehavior&gt;_When_&lt;StateUnderTest&gt;.</p><h2 id=\">Do You Know These Test Doubles?</h2>\n\n<p id=\">When writing your code, knowing the following terms is crucial:</p><h3 id=\">Dummy</h3>\n\n<p id=\">The most basic term you have to know is the Dummy. A Dummy is a placeholder required to pass the unit. The Dummy should not be accessed during the test. The simplest example might be null:</p><pre></pre><h3 id=\">Fake</h3>\n\n<p id=\">In automated testing it is common to use objects that implement the production interface and behave like it. Fakes are objects that have working implementations, but not the same as the production one. Fakes simplify the complexity of the external dependency setup. Fakes are frequently used for database access, openid connect endpoints or external APIs.</p><pre></pre><h3 id=\">Stub</h3>\n\n<p id=\">Stub is an object that holds predefined data and uses it to answer calls during tests. It provides indirect input to the unit from a dependency. Classic examples are objects, exceptions or primitive values which are returned from a method call.</p><pre></pre><h3 id=\"><strong id=\">Mock</strong></h3>\n\n<p id=\">Compared to a stub, allow mocks to verifying method invocation of the unit. An example is the service method invoking the repository method. </p><pre></pre><h3 id=\">Spy</h3>\n\n<p id=\">A Spy uses the original implementation and is the most complex version of a test double. It is a wrapper of the original implementation, so it records the number of calls and not the input. For example:</p><pre></pre><h2 id=\">How Are Test Methods Structured?</h2>\n\n<p id=\">There are two common practices to structure your test method. First the AAA-Pattern and the BDD-Pattern. The BDD-Pattern is not covered here.<br><br>The AAA-Pattern is commonly used in unit tests. This Acronym stands for <em id=\">arrange, act and assert</em> (Bill Wake). The test method code is structured in three blocks, as shown in the following example.</p><pre></pre><p id=\">Now let’s come to a conclusion. Unit Testing is an art that is easy to learn (and not too hard to master) if you follow the instructions given in this overview. Now that you know about all the characteristics, basic coding examples and patterns, we suggest you to always question your code (as Fowler would say): is my code comprehensible to everyone?</p><p id=\">This blog is based on a Unit Test input Dominik Klotz gave for the <a href=\"https://www.meetup.com/software-testing-karlsruhe/\" target=\"_blank\" id=\">Karlsruher Testing Community</a>.</p>",
  "category": "Tutorial",
  "readTime": "8 min read",
  "date": "2024-11-11",
  "publishedAt": "Mon Nov 11 2024 11:48:22 GMT+0000 (Coordinated Universal Time)",
  "author": "dominik-klotz",
  "image": "https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/671a0ae16d415eebeb2a2f8c_unittesting.webp",
  "featured": false,
  "contentPath": "unit-testing-in-a-nutshell.md"
}