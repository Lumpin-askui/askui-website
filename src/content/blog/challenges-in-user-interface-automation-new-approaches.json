{
  "id": "challenges_in_user_interface_automation_new_approa",
  "slug": "challenges-in-user-interface-automation-new-approaches",
  "title": "Challenges in User Interface Automation: New Approaches",
  "excerpt": "In this blog, we will discuss the problems that come with selector-based approaches and how current tools try to remedy them with Smart Selectors ....",
  "content": "<p id=\">In the <a href=\"https://www.askui.com/blog-posts/challenges-in-user-interface-automation-current-state\" id=\">previous blog</a> we saw, that automation with selector-based approaches is a proven way to automate UIs that are based on a structure like HTML. If you played around with our <a href=\"https://bit.ly/3rDP9PC\" id=\">Git repository</a> you noticed how fast the test execution runs.</p><p id=\">In this blog, we will discuss the problems that come with selector-based approaches and how current tools try to remedy them with Smart Selectors and Self-healing Tests.</p><h2 id=\">Problems With Selector-Based Approaches</h2><p id=\">When you look closely at the structure of the code under test and the test code you notice, that these two are intertwined. That leads to problems with large test suites.</p><blockquote id=\">Every change in the code under test can lead to changes in the structure (HTML) under test causing tests to fail. That is why large UI test suites usually become flaky.</blockquote><p id=\">You can combat this problem with a strong engineering culture that puts constraints on how the resulting HTML is structured. Putting ids in every element is also a valid solution. But the main issue remains: You are coupling the code under test with your test code!</p><h2 id=\">Smart Selectors</h2><p id=\">Smart Selectors promise a solution to the tight coupling of test code with the code under test.</p><p id=\">They help to implement Self-healing tests that can succeed, even when the element can not be detected due to wrong labeling like in the picture below (The button should have the id <em id=\">signIn</em> but it changed to <em id=\">anmelden</em>):</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1b6181cd696ee4351e9_6346af513e71cb800c0e35e7_self_healing_test_card_slide.png\" loading=\"lazy\" alt=\"The id-selector signIn does not find the element, because it was accidentally renamed to anmelden\" id=\" width=\"auto\" height=\"auto\"></div><figcaption id=\">The id-selector <em id=\">signIn</em> does not find the element, because it was accidentally renamed to <em id=\">anmelden.</em></figcaption></figure><p id=\">The following three approaches are followed, which often are then combined with classic selectors in practice to reliably recognize elements.</p><h2 id=\">Optical Character Recognition (OCR)</h2><p id=\">OCR is the recognition of text from images. The technology has been used for a long time for various use cases and has now also established itself in UI automation tools.</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1b6181cd696ee4351fb_6346afbbb5069eaa663272af_ocr_card_slide.png\" loading=\"lazy\" alt=\"Different wrong spellings of Apple get recognized.\" id=\" width=\"auto\" height=\"auto\"></div><figcaption id=\">Different wrong spellings of <em id=\">Apple</em> get recognized.</figcaption></figure><h2 id=\">Picture in Picture Search</h2><p id=\">Picture-in-Picture search refers to the search of cut-out elements on the UI by pixel matching. The element is usually cut out and stored as an image. If you want to select this element in a test, the picture runs over the entire UI and tests for a match between the cut-out picture and the actual UI.</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1b6181cd696ee4351f7_6346afe1b178d5c81eab73bf_picture_in_picture_slide.png\" loading=\"lazy\" alt=\"Detect Login button with a cut-out picture of it.\" id=\" width=\"auto\" height=\"auto\"></div><figcaption id=\">Detect Login button with a cut-out picture of it.</figcaption></figure><h2 id=\">Relations</h2><p id=\">A new approach is relative locators, which were also introduced in Selenium 4. The functionality is simple: Instead of selecting an element directly, it is addressed via the relation to other elements.</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1b6181cd696ee4351f2_634d0db6a542557830af3bde_relations_card_slide_new.png\" loading=\"lazy\" alt=\"Type test in textfield below email.\" id=\" width=\"auto\" height=\"auto\"></div></figure><p id=\">For example, a text field for <em id=\">Username</em> can be found by its relation to the <em id=\">Login</em>-Button as in the following example:</p><figure id=\" class=\"w-richtext-figure-type-image w-richtext-align-fullwidth\" data-rt-type=\"image\" data-rt-align=\"fullwidth\" data-rt-max-width=\"><div id=\"><img src=\"https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/6634d1b6181cd696ee4351ef_6346b07cb178d50b72ac3479_Login_Form_With_Textfield_Label.png\" loading=\"lazy\" alt=\"Login form with label username, right of it a text field and a button.\" id=\" width=\"auto\" height=\"auto\"></div></figure><p id=\">The Open Source library <a href=\"https://taiko.dev/\" id=\">Taiko</a> can detect elements based on relation.</p><pre></pre><p id=\">You can find the full example in our <a href=\"https://bit.ly/3rDP9PC\" id=\">Git Repository</a>.</p><h3 id=\">Are Self-healing Tests a Good Idea?</h3><p id=\">Self-healing Tests sound great in theory. However, it is a two-edged sword in our opinion. They will ease the pain of flaky tests, but come with two caveats:</p><ul id=\"><li id=\">You need to implement and maintain the backup steps</li><li id=\">A test that might fail remains green and can mask a real error</li></ul><p id=\">ðŸ’¡ So be conscious and deliberate about deploying this technique. ðŸ’¡ </p><h2 id=\">Conclusion</h2><p id=\">Smart Selectors can help you write more robust tests by employing techniques that do not rely solely on the structure of the code (HTML) under test.</p><p id=\">OCR, Picture-in-Picture search, and relational selectors are available in tools today and in recent years get combined with Machine Learning/AI to ease the pain of maintaining large test suites.</p><p id=\">In the last installment of the series, we will look at currently <em id=\">untestable</em> User Interfaces like 2D Planes and canvases and show how cutting-edge and future products will enable UI automation for these use cases.</p><p id=\"><a href=\"https://askui.circle.so/getting-started\" id=\">Do you want to know more about UI automation's future with askui? Join our community!</a></p>",
  "category": "Academy",
  "readTime": "3 min read",
  "date": "2024-11-11",
  "publishedAt": "Mon Nov 11 2024 11:22:15 GMT+0000 (Coordinated Universal Time)",
  "author": "johannes-dienst",
  "image": "https://cdn.prod.website-files.com/6630f90ff7431b0c5b1bb0e7/671a08e02a8036f35a5a30f9_newapproaches.webp",
  "featured": false
}